---
format:
  gfm:
    toc: false
    echo: false
output-dir: docs
execute:
  echo: false
  warning: false
  message: false
---
```{r setup, include = F}
setwd(here::here())
source("code/_master_code.R")
```
# Analisi del primo elefante (id: GON09)

## Analisi esplorativa dei dati 

L'istogramma rappresenta la distribuzione del turn angle nelle tre stagioni climatiche

```{r visualizzazione}
# data 
GON09 <- read_csv(paste0(dir_data, "/GON09.csv"))
# turn angle
ggplot(data = GON09, aes(x = ta_, y = ..density..)) +
  geom_histogram(color = "black", fill = NA) +
  geom_density() +
 facet_wrap(~ seas) +
  theme_test() +
  xlab("Turn angle") +
  ylab("Density")
```

## Modello di base

Vogliamo verificare se il *turn angle* sia influenzato dalle variabili a disposizione, cioè la distanza dalla riva `distriv`, l'altitudine `elev`, l'indice `ndvi` e la stagione `seas`. 

* La funzione di verosimiglianza è definita assumendo 

$$
\boldsymbol{\mu} = 2 \cdot \arctan(\mathbf{X} \boldsymbol{\beta}) = 2 \cdot \arctan(\eta_i)
$$

 dove:

* $\mathbf{X} = (1, \text{distriv}, \text{elev}, \text{ndvi}, \text{seas})$
* $\boldsymbol{\beta} = (\beta_0, \beta_1, \dots, \beta_k)$
*  In altri termini, assumiamo per il turn angle (`ta`) il seguente modello: 

$$
y_i \propto \beta_0 + \beta_1 \cdot \text{distriv}_i + \beta_2 \cdot \text{elev}_i + 
\beta_3 \cdot \text{ndvi}_i + \beta_4 \cdot \text{seasCD}_i + \beta_5 \cdot \text{seasHD}_i
$$

*   La variabile `seas` è trattata come fattore con base la stagione "hot dry" (`HD`);
*   Le covariate sono standardizzate per migliorare l'interpretabilità dei coefficienti stimati. 
```{r MLE-Von-Mises}
# fit ----
fit_std <- optim(
  par = c(rep(0,6), log(2)),
  fn = log.lik.VM, 
  data = GON09, 
  formula = ~ distriv_std + elev_std + ndvi_std + seas, 
  response = "ta_",
  control = list(maxit = 10000),
  hessian = T
)
# risultati ----
#     tabella ----
tibble(
  parametri = c("Intercept", "Distance from water", "Elevation", "NDVI Index", "Seas = CD", "Seas = HD", "Kappa"),
  estimate = c(fit_std$par[1:6], exp(fit_std$par[7])), 
  se = sqrt(diag(solve(fit_std$hessian))),
  lower = estimate - qnorm(0.975) * se,
  upper = estimate + qnorm(0.975) * se,
  W = estimate / se, 
  p_value = 2 * (1 - pnorm(abs(W)))
) %>% 
  kable(
    col.names = c("Parameter", "Estimate", "Std. Error", "95% CI Lower", "95% CI Upper", "Wald test", "p-value"),
    align = "lcccc",
    format = "markdown", 
    
  )
#     grafico dei coefficienti ----
tibble(
  parameter = factor(c("Intercept", "Distance from water", "Elevation", "NDVI Index",
                       "Seas = CD", "Seas = HD", "Kappa"),
                     levels = c("Intercept", "Distance from water", "Elevation", "NDVI Index",
                                "Seas = CD", "Seas = HD", "Kappa")),
  estimate = c(fit_std$par[1:6], exp(fit_std$par[7])), 
  se = sqrt(diag(solve(fit_std$hessian))),
  lower = estimate - qnorm(0.975) * se,
  upper = estimate + qnorm(0.975) * se
) %>%
  ggplot(aes(estimate, parameter)) +
  geom_point() +
  geom_errorbarh(aes(xmin = lower, xmax = upper)) +
  geom_vline(xintercept = 0, lty = 2, color = "red") +
  labs(
    x = "Estimate with conf. intervals"
  ) +
  theme_test()
#       curve di regressione al variare di distriv ----
expand_grid(
  distriv_seq = seq(
    from = -10,
    to = 10,
    length.out = 100
  ),
  seas = c("HW", "CD", "HD")) %>% 
  mutate(
    seasCD = as.numeric(seas == "CD"),
    seasHD = as.numeric(seas == "HD"),
    mu = 2 * atan(fit_std$par[1] + distriv_seq * fit_std$par[2] + seasCD * fit_std$par[5] + seasHD * fit_std$par[6])
  ) %>% 
  ggplot(aes(x = distriv_seq, y = mu, color = seas)) +
  geom_line() +
  labs(
    x = "Distance from water",
    y = "Turn angle"
  ) + 
  scale_y_continuous(limits = c(-pi, pi)) +
  theme_test()
```

### Analisi dei residui

I residui ($res = y^{oss} - \hat{y}$) sono sempre compresi in $-\pi$ a $+\pi$ e assumono i seguenti valori: 

- $> 0$ se $y^{oss} > \hat{y}$ cioè quando gira più a sinistra (senso antiorario) rispetto al previsto
- $< 0$ se $y^{oss} < \hat{y}$ cioè quando gira più a destra (senso orario) rispetto al previsto

Si vuole verificare se i residui al tempo $t$ siano correlati con i residui al tempo $t-1, \dots, t - n$ 

- Trattandosi di dati angolari il coefficiente di correlazione è definito come [see @fisher_statistical_2000]: 
 
$$
 \rho_c(\alpha, \beta) = \frac{E\{ sin(\alpha - \mu) sin(\beta - \nu) \}}{\sqrt{\text{Var}(sin(\alpha - \mu)) \text{Var}(sin(\beta - \nu)) }}
$$

Un problema che si incontra con questo dataset riguarda il fatto che non tutte le osservazioni sono ad intervalli regolari tra di loro

- Le osservazioni della stessa *burst* hanno una differenza di quattro ore tra una e l'altra, ma tra una *burst* e un'altra la distanza temporale è molto superiore 
- Per ovviare a questo problema la funzione cerca un *match* tra l'orario desiderato e un'orario osservato nei dati

```{r residui}
residuals <- GON09 %>%
  arrange(t1_) %>%
  mutate(
    seasCD = as.numeric(seas == "CD"),
    seasHD = as.numeric(seas == "HD"),
    ta_hat = 2 * atan(fit_std$par[1] + 
                        fit_std$par[2] * GON09$distriv_std + 
                        fit_std$par[3] *  GON09$elev_std+ 
                        fit_std$par[4] * GON09$ndvi_std+ 
                        fit_std$par[5] * seasCD + 
                        fit_std$par[6] * seasHD)
  ) %>% 
  dplyr::select(t2_, ta_, ta_hat) %>% 
  dplyr::filter(!is.na(ta_)) %>% 
  mutate(
    res = (ta_ - ta_hat),
    t2_ = round_date(t2_, unit = "hours")
  ) %>% 
  select(t2_, res)

# calcolo ACF ----
ACF <- map_dfr(
  .x = 1:42, 
  .f = ~acf_circular(lag = .x, x = residuals)
) 
# risultati ----
ACF %>%
  mutate(
    total_hours = lag * 4,
    days = floor(total_hours / 24),
    hours = total_hours %% 24,
    lag_label = case_when(
      days > 0 & hours > 0 ~ paste0(days, " days ", hours, " hours"),
      days > 0 & hours == 0 ~ paste0(days, " days"),
      days == 0 & hours > 0 ~ paste0(hours, " hours"),
      TRUE ~ "0 hours"
    ),
    signif = ifelse(p.value < 0.05, "*", "")
  ) %>% 
  select(lag_label, n_match, acf, statistic, p.value, signif) %>%
  kable(format = "markdown",
        col.names = c("Lag", "# of matches", "ACF", "Statistic", "p-value", "Signif"),
        align = c("l", "c", "c", "c", "c", "c"))

ACF %>%
  mutate(signif = ifelse(p.value < 0.05, "Significant", "Not significant")) %>% 
  ggplot(mapping = aes(x = lag, y = acf)) +
  geom_hline(yintercept = 0) +
  geom_segment(mapping = aes(
    xend = lag, 
    yend = 0,
    colour = signif)) +
  scale_colour_manual(values = c("black", "red")) +
  theme_test() +
  labs(
    x = "Lag",
    y = "ACF",
    colour = "p-value < 0.05"
  )
```

## Modello AR(1) 

Dato che dalla funzione di autocorrelazione emerge una correlazione significativa dei primi 4 lag, cioè i residui al tempo $t-1$ (4 ore), $t-2$ (8 ore), $t-3$ (12 ore), $t-4$ (16 ore) sono correlati con i residui al tempo $t$, e non è quindi possibile assumere indipendenza tra le osservazioni, la funzione di log-verosimiglianza è ridefinita per tenerne conto come segue: 

- Siano: 
 - $\eta = \mathbf{X}\boldsymbol{\beta}$: il predittore lineare 
 - $e_{t-1} = y_{t-1} - 2 \cdot \arctan(\eta_{t-1})$: i residui al tempo t-1
- Assumiamo:

$$
\mu_t = 2 \cdot \arctan(\eta_{t}) + \arctan(\frac{\phi \cdot \sin(e_{t-1})}{k_t})
$$

e

$$
k_t = \sqrt{k^2 + [\phi \cdot \sin(e_{t-1})]^2}
$$

```{r AR1}
# fit ----
fit_ar1 <- optim(
  par = c(rnorm(8), log(2)),
  fn =  log.lik.VM.ar,
  data = GON09,
  formula = ~ sl_ + distriv_std + ndvi_std + elev_std + seas,
  response = "ta_",
  burst = "burst_",
  method = "L-BFGS-B",
  hessian = TRUE,
  control = list(maxit = 1000)
)
# risultati ----
#     tabella ----
tibble(
  parameter = c("Intercept", "Step Length", "Distance from water", "NDVI Index", "Elevation", "Season = HD", "Season = HW", "Phi" , "Kappa"),
  estimate = c(fit_ar1$par[1:8], exp(fit_ar1$par[9])), 
  se = sqrt(diag(solve(fit_ar1$hessian))),
  lower = estimate - qnorm(0.975) * se,
  upper = estimate + qnorm(0.975) * se,
  W = estimate / se, 
  p_value = 2 * (1 - pnorm(abs(W)))
) %>% 
  kable(
    col.names = c("Parameter", "Estimate", "Std. Error", "95% CI Lower", "95% CI Upper", "Wald test", "p-value"),
    align = "lcccc",
    format = "markdown"
  )
#     grafico dei coefficienti ----
tibble(
  parameter = c("Intercept", "Step Length", "Distance from water", "NDVI Index", "Elevation", "Season = HD", "Season = HW", "Phi" , "Kappa"),
  estimate = c(fit_ar1$par[1:8], exp(fit_ar1$par[9])), 
  se = sqrt(diag(solve(fit_ar1$hessian))),
  lower = estimate - qnorm(0.975) * se,
  upper = estimate + qnorm(0.975) * se,
  W = estimate / se, 
  p_value = 2 * (1 - pnorm(abs(W)))
) %>% 
  ggplot(aes(estimate, parameter)) +
  geom_point() +
  geom_errorbarh(aes(xmin = lower, xmax = upper)) +
  geom_vline(xintercept = 0, lty = 2, color = "red") +
  labs(
    x = "Estimate with conf. intervals"
  ) +
  theme_test()
```
### Verifiche sul fit 
```{r Verifiche sul fit}
par <- fit_ar1$par
X <- model.matrix(~ sl_ + distriv_std + ndvi_std + elev_std + seas,
                  GON09)
y <- GON09$ta_
burst <- GON09$burst_

# parametri ----
beta <- par[1:ncol(X)]
phi <- par[ncol(X) + 1]
kappa <- exp(par[ncol(X) + 2])

# log-likelihood ----
eta <- X %*% beta
l_data <- tibble(
  burst = burst,
  y = y,
  eta = as.vector(eta)
) %>% 
  group_by(burst) %>% 
  mutate(
    res = y - 2 * atan(eta),
    kappa_t = sqrt(kappa^2 + (phi * sin(lag(res)))^2),
    mu_t = 2 * atan(eta) + atan(phi * sin(lag(res)) / kappa_t),
    res_t = y - mu_t
  ) %>% 
  slice(3:n())

# Istogramma dei residui 
ggplot(data = l_data, aes(x = res_t)) +
  geom_histogram(fill = "transparent", color = "black") +
  theme_test() +
  labs(
    title = "Istogramma dei residui",
    x = "Residui"
  )

# Residuals vs Fitted 
ggplot(l_data, aes(x = mu_t, y = res_t)) +
  geom_point() +
  theme_test() +
  geom_hline(yintercept=0, 
             linetype="dashed", 
             color = "red") +
  labs(
    title = "Residuals vs Fitted",
    x = "Fitted values", 
    y = "Residuals"
  )

# Istogramma Fitted vs Observed 
ggplot(l_data, aes(x = y)) +
  geom_histogram(aes(y = ..density.., fill = "Observed"),
                 bins = 30, 
                 position = "identity", 
                 color = NA) +
  geom_histogram(aes(x = mu_t, y = ..density.., fill = "Fitted"), 
                 alpha = 0, 
                 bins = 30, 
                 position = "identity", 
                 color = "black") +
  scale_fill_manual(
    values = c("Observed" = "red", "Fitted" = "black"),
    name = NULL
  ) +
  labs(
    title = "Fitted vs Observed",
    x = "Angle (radians)",
    y = "Density"
  ) +
  theme_test()

# QQ plot Fitted vs Observed
ggplot(data = l_data, aes(x = sort(mu_t), y = sort(y))) +
  geom_point(size = 2, shape = 1) +
  theme_test() +
  labs(
    title = "QQplot: Fitted vs Observed",
    x = "Fitted", 
    y = "Observed"
  )
```