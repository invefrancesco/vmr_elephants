<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Francesco Invernizzi">

<title>Introduzione ai Modelli Mistura (MM)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="mm_intro_files/libs/clipboard/clipboard.min.js"></script>
<script src="mm_intro_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="mm_intro_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="mm_intro_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="mm_intro_files/libs/quarto-html/popper.min.js"></script>
<script src="mm_intro_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="mm_intro_files/libs/quarto-html/anchor.min.js"></script>
<link href="mm_intro_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="mm_intro_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="mm_intro_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="mm_intro_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="mm_intro_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Introduzione ai Modelli Mistura (MM)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Francesco Invernizzi </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>We often make simplifying modeling assumptions when analyzing a data set such as assuming each observation comes from one specific distribution (say, a Gaussian distribution). Then we proceed to estimate parameters of this distribution, like the mean and variance, using maximum likelihood estimation.</p>
<p>However, in many cases, assuming each sample comes from the same unimodal distribution is too restrictive and may not make intuitive sense. Often the data we are trying to model are more complex. For example, they might be <strong>multimodal</strong> – containing multiple regions with high probability mass. In this note, we describe <strong>mixture models</strong> which provide a principled approach to modeling such complex data.</p>
<section id="example-1" class="level3">
<h3 class="anchored" data-anchor-id="example-1">Example 1</h3>
<p>Suppose we are interested in simulating the price of a randomly chosen book. Since paperback books are typically cheaper than hardbacks, it might make sense to model the price of paperback books separately from hardback books. In this example, we will model the price of a book as a <strong>mixture model</strong>. We will have two <strong>mixture components</strong> in our model – one for paperback books, and one for hardbacks.</p>
<p>Let’s say that if we choose a book at random, there is a 50% chance of choosing a paperback and 50% of choosing hardback. These proportions are called <strong>mixture proportions</strong>. Assume the price of a paperback book is normally distributed with mean <span class="math inline">\(9\)</span> and standard deviation <span class="math inline">\(1\)</span> and the price of a hardback is normally distributed with a mean <span class="math inline">\(20\)</span> and a standard deviation of <span class="math inline">\(2\)</span>.</p>
<p>We could simulate book prices in the following way:</p>
<ol type="1">
<li>Sample <span class="math inline">\(u_1, \dots, u_n\)</span> from <span class="math inline">\(U \sim \text{Bernoulli}(0.5)\)</span><br>
</li>
<li>If <span class="math inline">\(u_i = 0\)</span> draw <span class="math inline">\(p_i\)</span> from the paperback distribution <span class="math inline">\(N(9,1)\)</span>. If <span class="math inline">\(u_i = 1\)</span>, draw <span class="math inline">\(p_i\)</span> from the hardback distribution <span class="math inline">\(N(20,2)\)</span>.</li>
</ol>
<p>We implement this simulation in the code below:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12345</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">vector</span>()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5000</span>) {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    z_i <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="fl">0.5</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (z_i <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        p[i] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, <span class="dv">9</span>, <span class="dv">1</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        p[i] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, <span class="dv">20</span>, <span class="dv">2</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>We see that our histogram is bimodal. Indeed, even though the <strong>mixture components</strong> are each normal distributions, the distribution of a randomly chosen book is not. We illustrate the true densities below:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mm_intro_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We see that the resulting probability density for all books is bimodal, and is therefore not normally distributed. In this example, we modeled the price of a book as a <strong>mixture</strong> of two <strong>components</strong> where each component was modeled as a Gaussian distribution. This is called a <strong>Gaussian mixture model</strong> (GMM).</p>
</section>
<section id="example-2" class="level3">
<h3 class="anchored" data-anchor-id="example-2">Example 2</h3>
<p>Now assume our data are the heights of students at the University of Chicago. Assume the height of a randomly chosen male is normally distributed with a mean equal to <span class="math inline">\(175\)</span> cm and a standard deviation of <span class="math inline">\(7\)</span> cm and the height of a randomly chosen female is <span class="math inline">\(N(160, 7)\)</span>. However, instead of 50/50 mixture proportions, assume that 75% of the population is female, and 25% is male.</p>
<p>We simulate heights in a similar fashion as above, with the corresponding changes to the parameters:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>height <span class="ot">&lt;-</span> <span class="fu">vector</span>()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5000</span>) {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    u_i <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="fl">0.75</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (u_i <span class="sc">==</span> <span class="dv">1</span>) {</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        height[i] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, <span class="at">mean =</span> <span class="dv">160</span>, <span class="at">sd =</span> <span class="dv">7</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        height[i] <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, <span class="at">mean =</span> <span class="dv">175</span>, <span class="at">sd =</span> <span class="dv">7</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Now we see that histogram is unimodal. Are heights normally distributed under this model? We plot the corresponding densities below:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="mm_intro_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Here we see that the Gaussian mixture model is unimodal because there is so much overlap between the two densities. In this example, you can see that the population density is not symmetric, and therefore not normally distributed.</p>
<p>These two illustrative examples above give rise to the general notion of a <strong>mixture model</strong> which assumes each observation is generated from one of <span class="math inline">\(K\)</span> mixture components. We formalize this notion in the next section.</p>
</section>
</section>
<section id="definition" class="level1">
<h1>Definition</h1>
<p>Assume <span class="math inline">\(X\)</span> is a random variable with distribution: <span class="math display">\[\begin{align}
X \sim
\begin{cases}
f_1(x;\theta) \quad &amp;if \quad U=1 \\
\vdots &amp;if \quad \vdots \\
f_k(x;\theta) \quad &amp;if \quad U=k
\end{cases}
\end{align}\]</span></p>
<p>and where <span class="math inline">\(U \in \{1, \dots, k\}\)</span> is the label indicating which component <span class="math inline">\(X\)</span> comes from. In our height example, the mixture component were <span class="math inline">\(f_{X\mid U_i = male} \sim N(175, 7)\)</span> and <span class="math inline">\(f_{X\mid U_i = female} \sim N(160, 7)\)</span>. Often times we don’t observe <span class="math inline">\(U\)</span> (e.g.&nbsp;we might just obtain a list of heights with no gender information), so the <span class="math inline">\(U\)</span>’s are called <strong>latent variables</strong>.</p>
<p>From the law of total probability, we know that the marginal probability of <span class="math inline">\(X\)</span> is: <span class="math display">\[f_X(x) = \sum_{u=1}^k f_{X \mid U=u}(x) \cdot \underbrace{P(U=u)}_{\pi_u} = \sum_{u=1}^k f_{X \mid U=u}(x;\theta_u) \cdot \pi_u, \qquad \pi_u \geq 0, \sum_{u=1}^k \pi_u = 1\]</span></p>
<p>Here, the <span class="math inline">\(\pi_u\)</span> are called <strong>mixture proportions</strong> or <strong>mixture weights</strong> and they represent the probability that <span class="math inline">\(X\)</span> belongs to the <span class="math inline">\(u\)</span>-th mixture component. The mixture proportions are non-negative and they sum to one. We call <span class="math inline">\(f_{X|U=u}\)</span> the <strong>mixture component</strong>, and it represents the distribution of <span class="math inline">\(X\)</span> assuming it came from component <span class="math inline">\(u\)</span>. For discrete r.v. these mixture components can be any PMF and for continuous r.v. they can be any PDF. The mixture components in our examples above were normal distributions.</p>
<section id="mle-of-mixture-models" class="level2">
<h2 class="anchored" data-anchor-id="mle-of-mixture-models">MLE of mixture models</h2>
<p>If we observe random samples <span class="math inline">\(x_1,\ldots,x_n\)</span> from <span class="math inline">\(X_1, \dots, X_n\)</span> i.i.d. random variables with this mixture, then the likelihood function is: <span class="math display">\[L(\mathbf{\theta}, \pi; \mathbf{x}) = \prod_{i=1}^n f(x_i) = \prod_{i=1}^n\sum_{u=1}^k \pi_u f_u(x_i; \theta_u)\]</span> where <span class="math inline">\(f_u = f_{X \mid U = u}\)</span>.</p>
<p>For instance, assuming we are in the Gaussian mixture model setting where the <span class="math inline">\(u\)</span>-th component is <span class="math inline">\(N(\mu_u, \sigma_u)\)</span> and the mixture proportions are <span class="math inline">\(\pi_u\)</span>, a natural next question to ask is how to estimate the parameters <span class="math inline">\(\{\mu_k,\sigma_k,\pi_k\}\)</span> from our observations <span class="math inline">\(\mathbf{x} = \{x_1, x_2, \dots, x_n\}\)</span>.</p>
<p>In order to find the <strong>maximum likelihood estimates</strong> for the parameters, we would have to maximize this function. Often, it is easier to maximize the log-likelihood function. In some cases a closed form can be derived by just setting the derivative with respect to <span class="math inline">\(\theta\)</span> to zero. However, things are not always as easy, as the following example will show.</p>
<p>In the case of mixture models, the log-likelihood function would become: <span class="math display">\[\begin{align}
\ell(\theta, \pi; \mathbf{x})
  &amp;= \log L(\theta, \pi; \mathbf{x}) \\
  &amp;= \sum_{i = 1}^n \log f(x_i) \\
  &amp;= \sum_{i = 1}^n \log \left(\sum_{u=1}^k \pi_u f_u(\mathbf{\theta}; x_i)\right)
\end{align}\]</span></p>
<p>Since the logarithm is outside the sum, optimization of this term is not an easy task.</p>
</section>
<section id="introduction-to-em" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-em">Introduction to EM</h2>
<p>Intuitively, if the latent variable <span class="math inline">\(U\)</span> was known, the maximization of the function would be much easier. In fact, we would just have to maximize the parameters <span class="math inline">\(\theta_u\)</span> for each joint distribution and than take the weighted average to obtain the marginal.</p>
<p>Formally, the PDF (and the corrispondent PMF for discrete variables) could be written as: <span class="math display">\[\begin{align}
f_{X, U} (x, u; \theta, \pi) = \prod_{u=1}^k [ \pi_u f_u(x; \theta_u)]^{I(U=u)}
\end{align}\]</span></p>
<p>where <span class="math inline">\(I(U=u)\)</span> is the indicator r.v. taking value 1 when the latent variable <span class="math inline">\(U=u\)</span></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>if <span class="math inline">\(U = 3\)</span> with <span class="math inline">\(k=3\)</span> categories the PDF would become: <span class="math display">\[\begin{align}
f_{X, U} (x, u; \theta, \pi) = \pi_1^0  f_1^0 \pi_2^0f_2^0 \pi_3^1f_3^1 = \pi_3 f_3
\end{align}\]</span></p>
</div>
</div>
<p>This form, in the case of a random sample from <span class="math inline">\(X1, \dots, X_n\)</span> i.i.d. random variables where each <span class="math inline">\(X_i\)</span> is labeled with a caregory <span class="math inline">\(U_i\)</span> would lead to the likelihood function: <span class="math display">\[\begin{align}
L(\theta, \pi; \mathbf{x}, \mathbf{u}) = \prod_{i=1}^n f(x_i) &amp;= \prod_{i=1}^n \prod_{u=1}^k [\pi_u f_u(x; \theta_u)]^{I(U=u)} \\
\ell(\theta, \pi; \mathbf{x}, \mathbf{u}) &amp;= \sum_{i=1}^n \sum_{u=1}^k I(U=u) \log [\pi_u f_u(x_i; \theta_u)]
\end{align}\]</span></p>
<section id="expectation-step" class="level3">
<h3 class="anchored" data-anchor-id="expectation-step">Expectation step</h3>
<p>The problem in the present case of the complete data likelihood function is that we did not observe the complete data (u is missing!). It may be surprising, but this problem of dealing with unobserved data in the end facilitates calculation of the ML parameter estimate.</p>
<p>In order to find this estimate, it is important to note that each entry of <span class="math inline">\(u\)</span> is a realization of a random variable. In our height example, being a male or a female is the realization of a random variable.</p>
<p>However, since these realizations are not observable in reality, we have to consider each entry of <span class="math inline">\(u\)</span> as a random variable itself. So, the whole likelihood function is nothing else than a function of a random variable and therefore by itself is a random variable (a quantity which depends on a random variable is a random variable). This means we can also take its expectation given the observed data and parameters. By linearity of expectation:</p>
<p><span class="math display">\[\begin{align}
E[\ell(\theta, \pi; \mathbf{x}, \mathbf{u}) \mid \mathbf{x}, \theta, \pi]
  &amp;= E\left[\sum_{i=1}^n \sum_{u=1}^k I(U=u) \log [\pi_u f_u(x_i; \theta_u)] \mid \mathbf{x}, \theta, \pi \right] \\
  &amp;= \sum_{i=1}^n \sum_{u=1}^k E[I(U=u) \mid \mathbf{x}, \theta, \pi ] \log [\pi_u f_u(x_i; \theta_u)]
\end{align}\]</span></p>
<p>Now recall that <span class="math inline">\(I(U=u)\)</span> is a Bernoulli r.v. and that its posterior probability <span class="math inline">\(P(U=u \mid \mathbf{x}, \theta, \pi)\)</span> can be evaluated by Bayes’ theorem.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Bayes’s theorem states that <span class="math display">\[\begin{align}
P(A|B) = \frac{P(A \cap B)}{P(B)} = \frac{P(B|A)P(A)}{P(B)}
\end{align}\]</span></p>
<p>In this case:</p>
<ul>
<li><span class="math inline">\(P(A\mid B)\)</span> is: <span class="math inline">\(P(U=u \mid x, \theta, \pi)\)</span></li>
<li><span class="math inline">\(P(B \mid A)\)</span> is the <span class="math inline">\(u\)</span>th mixture component: <span class="math inline">\(f_u(x; \theta)\)</span></li>
<li><span class="math inline">\(P(A)\)</span> is the a-priori probability of <span class="math inline">\(u\)</span>: <span class="math inline">\(P(U=u) = \pi_u\)</span></li>
<li><span class="math inline">\(P(B)\)</span> is the marginal probability (or density) of observing <span class="math inline">\(x\)</span> under the mixture: <span class="math inline">\(f_X(x; \theta, \pi) = \sum_{u=1}^k f_u(x; \theta) \pi_u\)</span></li>
</ul>
</div>
</div>
<p><span class="math display">\[
P(U=u \mid x, \theta, \pi) = \frac{f_u(x; \theta_u) \pi_u}{\sum_{u=1}^k f_u(x; \theta_u) \pi_u}
\]</span></p>
<p>The <strong>expectation step</strong> consists exactly in the estimation of posterior probabilities of U given a set of initial parameters.</p>
</section>
<section id="maximization-step" class="level3">
<h3 class="anchored" data-anchor-id="maximization-step">Maximization step</h3>
<p>Given a set of values for <span class="math inline">\(P(U=u \mid x, \theta, \pi)\)</span>, with <span class="math inline">\(u \in \{ 1, 2, \dots, k \}\)</span>, we can now find the values for <span class="math inline">\(\boldsymbol{\pi}\)</span> and <span class="math inline">\(\boldsymbol{\theta}\)</span> that maximize the expected log-likelihood function:</p>
<p><span class="math display">\[\begin{align}
E[\ell(\theta, \pi; \mathbf{x}, \mathbf{u}) \mid \mathbf{x}, \theta, \pi]
  &amp;= \sum_{i=1}^n \sum_{u=1}^k P(U=u \mid \mathbf{x}, \theta, \pi) \log [\pi_u f_u(x_i; \theta_u)]
\end{align}\]</span></p>
<p>After finding a set of parameters, we repeat the expectation step with the new parameters. After it, we iterate until convergence.</p>
<hr>
<p>https://www.cse.cuhk.edu.hk/~cslui/CSCI3320/Expectation%20Maximization%20-%20A%20Gentle%20Introduction.pdf</p>
<hr>
<p><strong>Acknowledgements</strong>:</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>